前端面试题

## 一、HTML + CSS   

### 1. 让一个宽高不定的子盒子在一个宽高不定的父盒子中垂直水平居中有哪些方法？

答案：

1. 主要有两种方式：定位和flex布局

2. 定位：

   1. 采用子绝父相定位方式(父亲也可以是绝对定位)。
   2. 通过边偏移top: 50%; 和left: 50%; 让子盒子往下和往右移动父盒子高度和宽度的一半。
   3. 再通过位移transform: translate(-50%, -50%);， 让子盒子往上和往左移动自身高度和宽度的一半。

   ```css
   body,html{
       height: 100%;
       width: 100%;
   }
   
   父盒子 {
       position: relative;
       
   }
   子盒子 {
       height: 100px
       width: 100px;
       position: absolute;
       top: 50%;
       left: 50%;
       transform: translate(-50%, -50%);
   }
   ```

3. flex布局：

   1. 通过display: flex;把父盒子设置为flex容器

   2. 给父盒子添加 justify-content: center; 让子元素沿主轴居中

   3. 给父盒子添加 align-items: center;  让子元素沿侧轴居中

      ```css
      父盒子 {
          display: flex;
          justify-content: center;
          align-items: center;
      }
      ```

拓展问题：

1. 面试官可能接下来会问，flex布局有什么缺陷？

   答：兼容性不太好，不能兼容ie9及以下版本的ie浏览器, 但是在移动端可以放心使用

2. flex布局中justify-content样式的两个属性space-between和space-around有什么区别？

   - `space-between`：两端对齐，项目之间的间隔都相等。
   - `space-around`：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

3. flex布局怎样使用？`flex:1`代表了什么？

4. flex布局怎样使用：

   > **背黑色加粗部分即可**

   1. 布局的传统解决方案，基于盒状模型，依赖 display属性 +position属性 + float属性。对于垂直居中之类的特殊布局非常不方便
   2. 2009年，W3C 提出了一种新的方案-Flex 布局可以简便、完整、响应式地实现各种页面布局。**flex布局中只需要给盒子添加`display: flex;` 就可以把盒子设置为flex容器，而他的直接子元素就成了flex项目，然后通过给flex容器和flex项目添加flex系列样式进行布局。**
   3. 一个注意点是，使用 Flex 布局以后，子元素的`float`、`clear`和`vertical-align`属性将失效。

5. `flex:1`代表了什么？

   > 参考：https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex

   1. `flex`属性是此属性是`flex-grow` + `flex-shrink` + `flex-basis` 的简写形式，`flex:1`的完整写法是： `flex: 1 1 0;`，等同于写了以下三j个样式。
   2. flex-grow: 1, 它指定了flex容器中剩余空间的多少应该分配给项目（flex增长系数）。

   3. `flex-shrink: 1` , **`flex-shrink`** 属性指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值划分的。

      如何理解：https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-shrink 

      ```js
   如何理解，举例说明：
          1. 如果父盒子宽度为 500px;   
          2. 父盒子中一共有5个子盒子
              1）每个子盒子的宽度为 120px
              2）前3个子盒子的 flex-shrink:1
              3）后2个子盒子的 flex-shrink:2
          3. 则实际每个盒子的宽度是如下计算的
              1) 子元素的宽度之和 = 120px * 5 = 600px
              2) 子元素超过父盒子的宽度  = 600px - 500px = 100px
                 就是说需要压缩的空间为 100px
              3) flex-shrink一共要压缩的份数 = 3 * 1 + 2 * 2 = 7
              4）每份要压缩的大小 = 100px / 7 约等于 14px
              5) 前3个子盒子每个盒子要压缩的大小 = 14px * 1 = 14px
                 因此前3个子盒子的最终大小 = 120px - 14px = 106px
              6) 后2个子盒子要压缩的大小 = 14px * 2 = 28px
                 因此后2个子盒子的最终大小 = 120px - 28px = 92px
      ```
   
   4. flex-basis: 0, **`flex-basis`** 指定了 flex 元素在主轴方向上的初始大小。

   

### 3. rem布局的原理是怎样的？在不同的手机端的表现是什么？你在实际开发中是如何做的？

答案：

1. rem布局的原理是怎样的？
   1. rem是一个相对单位，1rem=根元素html的font-size的大小
   2. 只要让页面上的元素采用rem作为单位，只要改变html根元素font-size的大小，页面上所有元素都跟着变大变小了。

2. 在不同的手机端的表现是什么？
   1. 在大屏手机所有内容可以实现整体变大。在小屏手机上整体变小。

3. 在实际开发中是如何做的？
   1. 项目中**安装和导入`flexible` 用于设置 rem 基准值。**这个包会将html根元素font-size的大小设置为屏幕宽度的十分之一，如浏览器的宽度为750px, 则 1rem = 75px， 如浏览器的宽度为1500px, 则 1rem = 150px。

   2. 设计稿上的尺寸单位是像素，项目中**使用postcss-pxtorem这款 PostCSS 插件，用于将 px 单位转化为 rem 单位。** 我们会在配置文件中将rootValue的值设置为UI设计稿宽度的1/10，这样在编写代码的时候从设计稿上拷贝过来的像素，就能被转换成特定的rem值。如设计稿为750px, 我们会把rootValue的值设置为75px。假设这种情况下设计稿中某个元素的宽度为150px,  当把元素的宽度设置为150px的时候，插件自动就会用150 / 75 = 2rem作为元素的宽度，免去了我们亲自换算的过程。

### 4. 为什么要清除浮动？清除浮动的方法有哪些？

1. 为什么要清除浮动？

   因为浮动的盒子脱离标准流，所以浮动的子盒子没有办法撑开父盒子。会导致如果父盒子没有设置高度的情况下，高度会为0，会影响后面的布局。

2. 如何清除浮动?

   ```
   clear：both；
   ```

3. 清除浮动的方法有？

   1. 额外标签法（在最后一个浮动标签后，新加一个标签，给其设置clear：both；）（不推荐）

   2. 父级添加overflow属性（父元素添加overflow:hidden）（不推荐）

   3. 使用after伪元素清除浮动（推荐使用）

      ```css
      .clearfix:after{/*伪元素是行内元素 正常浏览器清除浮动方法*/
          content: "";
          display: block;
          height: 0;
          clear:both;
          visibility: hidden;
      }
      .clearfix{
          *zoom: 1;/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/
      ｝
      ```

   4. 使用before和after双伪元素清除浮动

      ```css
      .clearfix:after,.clearfix:before{
          content: "";
          display: table;
      }
      .clearfix:after{
          clear: both;
      }
      .clearfix{
          *zoom: 1;
      }
      ```

### 5. h5c3新特性有哪些？

H5新特性:

1. 语义化更好的内容标签（header,nav,footer,aside,article,section） 

2. 音频、视频API(audio,video) 

3. 画布(Canvas) API 

4. 数据存储 localStorage、sessionStorage  

5. 表单控件，calendar、date、time、email、url、search、number

6. 地理(Geolocation) API 

   > 做定位的时候可以用到

7. 拖拽释放(Drag and drop) API 

   > 实现拖拽排序的时候可以用到

CSS3的新特性

   1.颜色：新增RGBA，HSLA模式 

2. 文字阴影（text-shadow） 

3. 边框圆角（border-radius）边框阴影： box-shadow 

4. 盒子模型：box-sizing 

5. 背景：background-size 设置背景图片的尺寸background-origin 设置背景图片的原点background-clip 设置背景图片的裁切区域，以”,”分隔可以设置多背景，用于自适应布局 

6. 渐变：linear-gradient、radial-gradient 

7. 过渡：transition，可实现动画 

8. 自定义动画

9. 在CSS3中引入的伪元素::selection. 

   > 实现选中元素有特殊样式时可以用到

10. 媒体查询，flex布局

11. border-image 

12. 2D转换：transform：translate(x，y) rotate(x，y) skew(x，y) scale(x，y) 

13. 3D转换 

14. 新增选择器：属性选择器、伪类选择器、伪元素选择器。 

    

思考：如果问你可以说说Canvas画布怎样使用的吗？这种自己没有学过也没有研究过的知识怎么办？

不要说不会，说没搞过。

## 二、JS + ajax 

### 6. ES6的新特性有哪些？let、var、const的区别？

答案：

1. ES6的新特性有哪些？

   1. 函数默认参数
   2. 模版字符串
   3. 解构赋值
   4. 拓展运算符...
   5. 箭头函数
   6. Promise
   7. async await
   8. let、const 和块级作用域
   9. 类class
   10. ES6中的模块化

2. var、let、const之间有什么区别？

   1. var存在变量提升，而 let，const声明的变量却不存在变量提升

   2. var声明的变量没有块级作用域，但let和const声明的变量具有块级作用域

   3. const声明的是常量，不可以改变，但let和var声明的是变量，可以改变。当然const声明常量不可改变对于简单数据类型而言指值不可以改变，对于复杂数据类型指地址不可以改变。

      

### 7. 普通函数和箭头函数内this指向有什么不同？如何改变this的指向？func.call  func.apply  和 func.bind有什么异同？

答案：

1. 普通函数和箭头函数内this指向有什么不同？

   1. 普通函数内this指向函数的调用者
   2. 箭头函数内this指向定义箭头函数处（也称上下文）this的指向，也就是说箭头函数定义的那里this指向什么，箭头函数内this就指向什么。

2. 如何改变this的指向？

   1. 可以通过 func.call  func.apply  和 func.bind来改变函数内this的指向

3. func.call  func.apply  和 func.bind有什么异同？

   1. 相同点：都可以改变调用函数时，函数内this的指向

   2. 不同点：

      1. .call和.apply会立即调用函数，.bind不会立即调用函数，而是返回一个新函数
      2. .call和.bind内参数是用逗号分隔开，而.apply中参数需写成数组的形式




### 8. async、await  是什么？它有哪些作用？

1. async await 是es6里面的新语法：

   - async 用于申明一个函数是异步的，调用async修饰的函数得到的是一个Promise的实例对象，不会阻塞线程。

   - await 用于等待一个异步方法执行完成， 可以替代promise中的then方法，优化写代码的方式。

   - 如果在函数内使用了await则该函数必须用async修饰。

     ```js
     // 读取a文件内容，写入到b文件中的案例
     // npm i then-fs
     import thenFs from 'then-fs'
     
     
     async function readWriteFile(){
         try{
             // 1. 读取出a.txt中的内容
             const data =  await thenFs.readFile('./a.txt', 'utf8')
             console.log(data);
             // 2. 把读取出来的内容写入到b.txt中
             await thenFs.writeFile('./b.txt', data, 'utf8')
             console.log('写入成功');
         } catch(err){
             console.log('读写失败：' + err.message);
         }
     }
     
     var result = readWriteFile()
     console.log(result);  // result为一个Promise的实例对象
     ```

### 9. 常用的数组方法有哪些？哪些会改变数组哪些不会。

> **不要求都记住，能够说出3-5个就可以了，挑自己感觉用得最多的记**

- **push()**        末尾追加。
- **unshift()**    头部追加。
- **pop()**          删除最后一个元素。
- **shift()**         删除第一个元素。
- **splice()**      通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。
- **reverse()**   翻转。 
- **sort()**         对数组的元素进行排序
- join()        把数组中的元素拼接成字符串（不会改变原数组）。
- concat()     合并多个数组（不会改变原数组）。
- forEach     迭代（不会改变原数组）。不能   对  只能终止回调函数
- filter           过滤（不会改变原数组）。
- map           映射（不会改变原数组，得到新数组）。
- findIndex  查找符合条件的第一个元素的索引，如果都不符合条件，则返回-1。
- every()      判断数组中是不是所有的元素都符合条件，如果都符合条件返回true，否则返回false。
- some()      判断数组中是不是有一个元素符合条件，如果有一个符合条件返回true，否则返回false。

### 10. 常用的字符串方法有哪些？

> **字符串的方法都不会改变字符串自身**

- trim()  去除前后空格
- split()   把字符串按某个字符切分成数组
- replace()   替换
- toUpperCase  把字符串中的小写英文字母转成大写
- toLowerCase  把字符串中的大写英文字母转成小写
- slice()  提取某个字符串的一部分。

### 11. js常用的数据类型有哪些？哪些是简单的数据类型，哪些是复杂的数据类型？

1. js常用的数据类型有：
   - 字符串
   - 数字
   - 布尔值
   - null
   - undefined
   - 数组
   - 对象
   - 集合
2. 简单的数据类型包括
   1. 字符串
   2. 数字
   3. 布尔值
   4. null
   5. undefined
3. 复杂的数据类型包括
   1. 数组
   2. 对象
   3. 集合

### 12. 简单数据类型和复杂数据类型在使用上有什么区别？

- 简单数据类型，在赋值的时候传递的是值，进行值的拷贝。

- 复杂数据类型，在赋值的时候传递的是地址。

- 简单数据类型，是不可变的数据类型，在不改变内存地址的情况下，不能改变其值。

  ```js
  var a = 1;
  a+= 1;
  console.log(a)  // 2
  // a的值虽然变成了2,  但是前提是：有赋值运算，a指向了全新的内存地址。
  ```

- 复杂数据类型，是可变的数据类型，在不改变内存地址的情况下，可以改变其值。

  ```js
  var arr = [1, 2, 3]
  arr.push(4)
  console.log(arr)  // [1, 2, 3, 4]
  // arr 指向的内存地址没变，但值发生了改变
  ```

### 13、什么是原型，说说原型的作用，说说原型三角关系？什么是原型链，原型链有什么作用？

1. 什么是原型，说说原型的作用和你对原型的理解？

   - 构造函数有一个prototype属性, 指向一个对象，这个对象我们称之为原型对象

   - 对原型的理解
     - 构造函数有一个prototype属性, 指向一个对象，这个对象我们称之为原型对象
     - 实例对象有一个`__proto__`属性，同样指向原型对象
     - 原型对象会有一个constructor的属性指回构造函数

   - 原型的作用
     - 当使用实例对象的属性和方法的时候，如果在自身身上查找不到就会去原型对象身上查找，所以原型能够实现属性和方法的共享

2. 什么是原型链，原型链有什么作用？

   - 什么是原型链？

     - 对象会有一个`__proto__`属性，指向对象的原型， 对象的原型对象会有一个`__proto__`属性指向原型对象的原型，原型对象的原型回有一个`__proto__`属性指向原型对象的原型对象的原型，这样利用

       `__proto__` 就可以形成链式查找关系，我们称之为原型链。

   - 原型链有什么作用？

     - 实现属性和方法的共享，如果在自身身上查找不到就通过`__proto__`属性找到原型对象，去原型对象身上去查找，如果在原型对象身上查不到，就通过`__proto__`属性找到原型对象的原型，去其身上查找，一直找到null对象身上为止。

### 14. 什么是闭包？有什么作用？能否手写一个闭包的示例代码？

1. 什么是闭包？

   如果A函数能访问B函数的内部变量，这种现象我们就称之为闭包

2. 有哪些优缺点

   优点：能延伸变量的作用范围

3. 能否手写一个闭包函数？

   可以

   > 闭包最常见的使用场景：定制一个函数
   >
   > 1. 外部函数嵌套内部函数
   >
   > 2. 内部函数使用外部函数的局部变量
   > 3. 返回内部函数或对内部函数的引用

   ```js
   function makeSizer(size) {
     // size是形参，等同于makeSizer函数的的局部变量
     return function() {
       // 内部函数使用了外部函数的size变量，因此形成了闭包  
       document.body.style.fontSize = size + 'px';
     };
   }
   
   var size12 = makeSizer(12);  // size12指向的函数，可以设置body的fontSize为12px
   var size14 = makeSizer(14);  // size14指向的函数，可以设置body的fontSize为14px
   var size16 = makeSizer(16);  // size16指向的函数，可以设置body的fontSize为16px
   ```

### 15. 谈谈你对http协议的理解？说说常见的http状态码有哪些，各有什么含义？

答案：

1. 谈谈你对http协议的理解？

   1. http协议中文名为超文本传输协议，是网页及网页中嵌套内容的传输协议。
   2. http协议具有以下三个特点：
      1. 规定了请求报文和响应报文的格式和内容。
      2. http协议是无状态的。
      3. http协议是构建在TCP协议之上的应用层协议。
   3. 具体来说：
      1. 规定了请求报文和响应报文的格式和内容：
         1. 请求包括：请求url地址、请求方式、请求头和请求体
         2. 响应包括：响应状态码、响应头和响应体
      2. http协议是无状态的，两次请求之间没有任何关系，因此在实际的项目开发中，我们会使用特定的会话跟踪技术（如JWT token）来记录用户的登录状态。
      3. http协议是构建在TCP协议之上的应用层协议，因此是数据传输过程是面向连接的，类似打电话(先建立连接，再传输数据，再断开连接)，数据传输可靠。

2. 说说常见的http状态码有哪些，各有什么含义？

   答案：

     常见的状态码包含以4类

   1. 1xx  表示目前为止一切正常, 客户端应该继续请求。
   2. 2xx 代表成功，200代表成功、201代表创建成功...
   3. 3xx 代表重定向，301 代表永久性重定向，302代表临时重定向
   4. **4xx 代表客服端错误**
      1. **400代表请求错误**
      2. **401代表认证失败（服务器不知道你是谁，token过期了）**
      3. **403代表没有权限（我可能知道你是谁，但是对不起你没有权限）**
      4. **404 没找到，请求资源不存在**
      5. **405 请求方式不支持（请求方式错误）**
   5. 5xx 代表服务器错误

   

### 16. axios的底层是用什么实现的? 

答案：

1. axios的底层是用`XMLHttpRequest`和`Promise`实现的

2. XMLHttpRequest负责在浏览器中发送请求。

3. Promise主要用来优化调用方式，解决回调地狱的问题。

   ```js
   // 自己去封装一个axios的函数
   function axios(option){
       // 1. 返回一个Promise的实例对象(代表发送网路请求的异步操作)
       return new Promise((resolve, reject)=>{
         // 2. 在Promise的回调函数中，通过xhr执行发送网路请求的异步操作
         const xhr = new XMLHttpRequest()
         xhr.open(option.method, option.url)
         xhr.onreadystatechange = function(){
           // 当网络请求响应成功的时候 xhr.readyState==4
           if (xhr.readyState==4){
             // 3. 成功通过resolve告知成功的结果，失败通过reject告知失败的结果
             // 状态码以2开头代表成功
             if(xhr.status.toString().startsWith('2')){
               // console.log(xhr.responseText);
               resolve(JSON.parse(xhr.responseText))
             }else{
               reject()
             }
           }
         }
         xhr.send()
       }) 
   }
   
   // 测试
   const res = axios({
       method: 'get',
       url: 'http://123.57.109.30:3006/api/getbooks'
   }).then
   console.log(res);
   ```

### 17. 什么是跨域? 跨域限制了什么？说说你知道有哪些解决跨域的办法？进一步说说他们的原理是怎样的？

答案：

1. 什么是跨域? 同源策略限制了什么？

   1. 如果两个资源地址之间存在协议、域名、端口号任何一个不相同，我们就说这两个资源地址之间跨域了。
   2. 同源策略限制了DOM、Cookie、ajax网络请求、LocalStorage和SessionStorage等的跨域访问。

2. 说说你知道有哪些解决ajax跨域的办法

   1. jsonp
   2. cors
   3. 关掉谷歌chrome浏览器的安全机制
   4. vue中的代理
   5. 部署

3. 他们的原理是怎样的？

   1. jsonp

      jsonp主要利用了script标签src属性不受同源策略限制的特点实现，返回的是函数的调用。

   2. cors

      cors在服务器端实现，前端开发者并不需要做什么，服务器在响应时会响应一组响应头，这些响应头告诉浏览器，允许接口被跨域的网站脚本访问。

   3. 关掉谷歌chrome浏览器的安全机制

      直接把浏览器中的同源策略给禁掉了，就不会限制跨域资源访问了。由于我们只能

   4. vue中的代理

      利用服务器调用接口不受跨域限制的特点实现，访问网页和Ajax请求都发给开发服务器，而ajax请求开发服务器帮会转发给真正的服务器，因此该技术只能在开发的时候使用。

   5. 前端应用和后台接口部署的时候，可以通过部署的技术，比如nginx，把网站应用和后台部署在同源的的地址下，这样就压根没有跨域的问题了。



### 18 说说axios中请求拦截器，响应拦截器各自的执行时机是怎样的？有什么作用？说说对token机制的理解？如何解决token可能过期的问题？

1. 说说axios中请求拦截器，响应拦截器各自的执行时机是怎样的？有什么作用？

   1. 请求拦截器在调用axio请求方法后，浏览器真正发起请求前执行。

      最常见的作用是可以在这里统一的为请求添加携带token的请求头

   2. 响应拦截器在浏览器拿到服务器响应数据后，axios拿到响应数据前执行。

      最常见的作用是在这里对token过期进行处理。

      ```js
      // 添加请求拦截器
      axios.interceptors.request.use(function (config) {
          // 在发送请求之前做些什么
          return config;
        }, function (error) {
          // 对请求错误做些什么
          return Promise.reject(error);
      });
      
      // 添加响应拦截器
      axios.interceptors.response.use(function (response) {
          // 对响应数据做点什么
          return response;
        }, function (error) {
          // 对响应错误做点什么
          return Promise.reject(error);
      });
      ```

2. 说说对token机制的理解？

   - token是身份令牌，通俗一点理解就是暗号；
   - 前端调用后台接口的时候在请求头中携带token，后端就能够通过对token解析，知道你是谁；

3. 如何解决token可能过期的问题？

   1. 我们怎么知道token过期了？
      1. 通过响应拦截器和状态码 。 状态码401：代表用户认证失败，token是过期的或者非法的
   2. token过期了怎么办？

      1. 重新登录
         1. 在响应拦截器中判断响应状态码是不是401，如果是401代表用户认证失败，token过期。
         2. 清空token, 并跳转到登录页，让用户重新登录。
      2. 使用 `refresh_token` 解决 `token` 过期： 
         1. 在响应拦截器中判断响应状态码是不是401，如果是401代表用户认证失败，token过期。
         2. 就通过refresh_token调用接口获取新的token,  再重新调接口就不会出现401了。
         3. 如果通过refresh_token调用接口获取新的token也失败，则说明refresh_token也过期，那就没办法，只能跳转到登录页，重新登录了。

### 19.  说说你对Promise的理解？Promise提供了哪些API，列举下，分别说说其作用。Promise.all和Promise.race有什么区别？

1. 说说你对Promise的理解？

   - Promise 是异步编程的一种解决方案，解决了传统解决方案回调函数容易形成回调地狱的问题，更便于开发与维护。Promise 并不会改变JS代码同步或异步执行的机制，只是一种新的写代码的方式。
   - Promise代表着某个异步任务，Promise存在三个状态，分别是pending  正在做，fulfilled完成了和rejected  失败了。

2. Promise提供了哪些API，列举下，分别说说其作用？

   - new Promise:  用于创建Promise实例对象

   - PromiseObj.then()：等待Promise异步任务执行完，在回调函数中拿到成功或失败的结果

   - PromiseObj.catch()：捕获Promise异步任务执行过程出现的异常

   - Promise.resolve()： 将普通对象转换成一个一定会成功的Promise对象

     ```js
     // 把'helloworld' 转换成一个Promise对象
     Promise.resolve('helloworld').then(data=>{    
         console.log(data) // 'helloworld'
     })
     ```

   - Promise.reject():  ： 将普通对象转换成一个一定会失败的Promise对象

     ```js
     Promise.reject('出错了').then(null, err=>{
     	console.log(err)//出错了
     })
     
     // 等价于
     new Promise((resolve,reject)=>{
     	reject('出错了')
     }).then(null,err=>{
     	console.log(err) //出错了
     })
     ```

   - Promise.all()： 运行所有。

   - Promise.race()：赛跑。

3. Promise.all和Promise.race有什么区别？

   - Promise.all()调用得到的是一个Promise实例对象，会运行所有的子Promise异步任务，等待所有子Promise异步任务执行完，再把结果汇总到数组中通过resolve告知调用者，如果任意一个失败，则通过reject告知失败的结果。

     简单点说，就是等待所有的都执行完，汇总成功的结果，只要有任意一个失败了就失败了。

     ```js
     Promise.all([promise1, promise2]).then(function(results) {
     	// results 是promise1和promise2 的结果组成的数组
         // Both promises resolved
     })
     .catch(function(error) {
     	// One or more promises was rejected
     });
     ```

   - Promise.race()调用得到的是一个Promise实例对象，会运行所有的子Promise异步任务，看其中哪个子Prmoise实例先执行完，哪个先运行完，就把哪个的结作为最终Promise.race()执行的结果。最快执行完得成功了就resolve其成功得结果，最快执行完得失败了就reject其错误。

     简单来说就是看谁跑得快,。剩下的就不管了。

     ```js
     Promise.race([promise1, promise2]).then(function(result) {
     	// result 是promise1和promise2中最先执行完的成功的结果
     }).catch(function(err) {
     	// err  是promise1和promise2中最先执行完的失败的结果
     });
     ```

### 20 防抖和节流：说说你对防抖和节流机制的认识，说说它们作用和应用场景有何不同，能手写出其核心代码吗？

1. **说说你对防抖和节流机制的认识**：

   - 防抖机制：指当事件被触发后，延迟 `n` 秒后再执行核心代码，如果在这 `n` 秒内事件又被触发，则重新计时。
   - 节流机制：是一种有效降低单位时间内，核心代码执行次数的机制。
   - （普通）节流阀：指当事件被触发后，延迟 `n` 秒后再执行核心代码，如果在这 `n` 秒内事件又被触发，则不进行任何处理。
   - （互斥）节流阀：指当事件被触发后，立即执行核心代码，在核心代码被执行完之前，再次触发，则不做任何处理。

2. **说说它们作用和应用场景有何不同**：

   - 防抖：如果事件被频繁触发，防抖能保证只有最后一次触发生效！前面 N 多次的触发都会被忽略！如：可以使用防抖技术优化搜索框建议词33。
   - 节流：如果事件被频繁触发，节流能够减少事件触发的频率，因此，节流是有选择性地执行一部分事件！如：可以使用节流优化滚动条滚动事件的监听，避免滚动事件的回调函数太过频繁执行。

3. **能手写出其核心代码吗**：

   - 防抖：

     ```js
     // 1. 定义一个变量指向延时器
     var timer = null;
     
     // 2. 某事件会触发的回调函数
     function doSomething(){
         // 2.1 先删除有可能已存在的延时器
         clearTimeOUt(timer);
         // 2.2 创建新的延时器
         timer = setTimeOut(function(){
             // 2.2.1 真正要执行的核心代码或调用核心函数
             // code...
     		console.log('核心代码')
         }, 500)
     }
     ```

   - 普通节流

     ```js
     // 1. 厕所门是打开的： null(打开)  有对象(关闭)
     var timer = null;
     
     // 2. 上厕所要调用的事件函数
     function doSomething(){
         // 2.1 如果厕所门是关着的，就不上测试了
         if(timer) return;
         // 2.2 如果厕所门是打开的
         // 2.2.1 上厕所之前先把厕所门给关上，而这个厕所有点特殊，至少得上16毫秒以上
         timer = setTimeOut(function(){
             // 2.2.2 上厕所（核心代码）
             // code...
     		console.log('核心代码')
             // 2.2.3 上完厕所之后把门打开
             timer = null;
         }, 16)
     }
     ```

   - 互斥节流

     ```js
     // 1. 厕所门是打开的： false(打开)  true(关闭)
     var flag = false;
     
     // 2. 上厕所要调用的事件函数
     function doSomething(){
         // 2.flag 如果厕所门是关着的，就不上测试了
         if(flag) return;
         // 2.2 如果厕所门是打开的
         // 2.2.1 上厕所之前先把厕所门给关上
         flag = true
         // 2.2.2 上厕所（核心代码）
         // code...
         console.log('核心代码')
         // 2.2.3 上完厕所之后把门打开
         flag = false;
     }
     ```

### 21 深浅拷贝 

1. 什么场景下需要用到拷贝？  

   如果调用函数的时候，传入了一个对象，函数内可能会对对象进行修改，可能不符合你的期待，这时候就需要用到拷贝

   ```js
   // 没有使用拷贝
   var obj = {}
   
   doSomething(obj)  // 调用某个会改变obj的函数
   
   obj可能发生变法
   
   
   // 使用了拷贝
   var obj = {}
   
   var newObj = JSON.parse(JSON.stringify(obj))
   
   doSomething(newObj)  // 调用某个会改变newObj的函数
   
   obj还是原来的obj
   ```

2. 拷贝对于简单数据类型有意义没有？

   - 对简单数据类型没有意义，因为简单数据类型，是不可变的数据类型，在不改变内存地址的情况下，不能改变其值。

     ```js
     var a = 1;
     a+= 1;
     console.log(a)  // 2
     // a的值虽然变成了2,  但是前提是：有赋值运算，a指向了全新的内存地址。
     ```

   - 复杂数据类型，是可变的数据类型，在不改变内存地址的情况下，可以改变其值。

     ```js
  var arr = [1, 2, 3]
     arr.push(4)
     console.log(arr)  // [1, 2, 3, 4]
     // arr 指向的内存地址没变，但值发生了改变
     ```
   
3. 什么是浅拷贝？什么是深拷贝？有什么区别？

   1. 浅拷贝指在进行数组或对象拷贝的时候只拷贝最外层，如果属性值是简单数据类型，拷贝其值，如果值是复杂数据类型，拷贝其地址。
   2. 深拷贝是递归的拷贝，深层次的拷贝，不管是简单数据类型还是复杂数据类型，拷贝的都是值。
   3. 区别
      1. 浅拷贝，修改拷贝出来的对象，有可能影响到原对象
      2. 深靠别，修改拷贝出来的对象，不会影响到原对象

4. 能否手写代码实现深拷贝？  

   1. 可以，通过递归或JSON模块可以实现。

   2. 通过JSON模块实现

      ```js
      function deepClone(obj) {
          if(typeof obj != 'object') return obj;
          return JSON.parse(JSON.stringify(obj))
      }
      
      // 测试
      var obj = {
          name: {
              addr: '天边'
          }
      }
      var obj1 = deepClone(obj);
      obj1.name.addr = '眼前'
      console.log(obj.name.addr);  // 打印输出 ‘天边’
      ```

   3. 通过递归实现

      ```js
      function deepClone(obj) {
          if (typeof obj != 'object') return obj;
          var temp = Array.isArray(obj) ? [] : {};
          for (let key in obj) {
              // 判断对象是否拥有该属性
              if (obj.hasOwnProperty(key)) {
                  if (obj[key] && typeof obj[key] == 'object') { // 如果obj[key]还是对象则执行递归
                      temp[key] = deepClone(obj[key]); // 递归
                  } else {
                      temp[key] = obj[key];
                  }
              }
          }
          return temp;
      }
      
      // 测试
      var obj = {
          name: {
              addr: '天边'
          }
      }
      var obj1 = deepClone(obj);
      obj1.name.addr = '眼前'
      console.log(obj.name.addr);  // 打印输出 ‘天边’
      ```

### 22 JS代码的执行机制

1. 说说同步和异步的执行顺序

   1. 先执行同步代码：
   2. 再执行异步代码
      1. 先执行异步代码中的微任务：如：Promise.then、.catch 和 .finally  . process.nextTick
      2. 再执行异步代码中的宏任务：如：异步 Ajax 请求、 setTimeout、setInterval、 文件操作 

2. 说说同步任务和异步任务的执行过程

   1. 同步任务由 JavaScript 主线程次序执行 
2. 异步任务委托给宿主环境执行 
   3. 已完成的异步任务对应的回调函数，会被加入到任务队列中等待执行 
   4. JavaScript 主线程的执行栈被清空后，会读取任务队列中的回调函数，按次序执行 
   5. JavaScript 主线程不断重复上面的第 4 步
   
3. 说说什么是EventLop(事件循环)机制

   JavaScript 主线程从“任务队列”中读取异步 任务的回调函数，放到执行栈中依次执行。这 个过程是循环不断的，所以整个的这种运行机 制又称为 EventLoop（事件循环）。

### 23 手写JS数组去重

> 方法无数种，挑其中的两三种实践下即可 https://www.cnblogs.com/MomentYY/p/15676743.html

- 方式一：利用集合Set()+Array.from()

  ```js
  const arr = [1, 2, 2]
  const result = Array.from(new Set(arr))
  console.log(result) // [ 1, 2]
  ```

- 方式二： 利用数组的includes方法

  ```js
  function removeDuplicate(arr) {
    const newArr = []
    arr.forEach(item => {
      if (!newArr.includes(item)) {
        newArr.push(item)
      }
    })
    return newArr
  }
  
  const arr = [1, 2, 2]
  const result = removeDuplicate(arr)
  console.log(result) // [ 1, 2]
  ```

- 方式三

  ```js
  function unique(arr) {
    return arr.filter(function(item, index, arr) {
      //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
      return arr.indexOf(item, 0) === index;
    });
  }
  
  const arr = [1, 2, 2]
  const result = unique(arr)
  console.log(result) // [ 1, 2]
  ```

### 24、数据类型的判断有哪些方法？他们的优缺点及区别是什么？

- typeof   得到数据对象的类型，缺点：只能检测出基本类型

- instanceof  用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。缺点：不好检测基本类型。

- constructor 基本能检测所有的类型（除了null和undefined） 缺点：constructor易被修改

- Object.prototype.toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的[[Class]]。其格式为[object Xxx] ，其中 Xxx 即为目标的类型，能检测出所有的类型，缺点是  IE6下，undefined和null均为Object

```js
// 利用 toString 封装的 typeOf 函数便能判断所有的js数据类型了
function typeOf(target){
	// Object.prototype.toString.call(target) 通过此便可获得目标的[[Class]]
	// 再由正则匹配 就能获得目标的类型
	// toLocaleLowerCase()将其转换为小写 留到下面扩展用
	return /^\[object (\w+)]$/.exec(Object.prototype.toString.call(target))[1].toLocaleLowerCase()
}
//原生typeof
typeOf(new Set())   // 'object'
typeof(null)        // 'object'''
typeOf(new Set())   // 'set''
typeOf(null)        // 'null'
```

| 不同类型的优缺点 | `typeof`得到类型   | instanceof                         | constructor                                 | Object.prototype.toString.call   |
| ---------------- | ------------------ | ---------------------------------- | ------------------------------------------- | -------------------------------- |
| 优点             | 使用简单           | 能检测出引用类型                   | 基本能检测所有的类型（除了null和undefined） | 检测出所有的类型                 |
| 缺点             | 只能检测出基本类型 | 不能检测出基本类型，且不能跨iframe | constructor易被修改，也不能跨iframe         | IE6下，undefined和null均为Object |

### 25. cookie、localStorage和sessionStorage

1. cookie、localStorage和sessionStorage有什么异同？

   - 相同
     - 都是浏览器本地存储空间，都可以存储数据，如token等
   - 不同主要体现在生命周期
     - localStorage  除非手动清除，否则一直存在那里
     - sessionStorage 关闭浏览器会话后，就自动移除了
     - cookie 可以设置有效期: 1可以设置指定的过期时间，2也可以指定关闭浏览器会话自动移除等
     - cookie 具有自动携带的特性，访问网页的时候，浏览器自动的会把域名下存储的cookie数据放到请求头中请求服务器

2. cookie和session有什么异同

   - 相同：
     - 由于http协议是无状态的，他们都是实现用户登录认证的一种会话跟踪技术。

   - 不同
     - cookie存储在浏览器客服端，不安全，不能把敏感的数据，直接明文放在cookie中。
     - session存储在服务器，是安全的，可以存储敏感数据。
     - session的实现依赖于cookie，session空间需要cookie来标识。

## 三、Vue   

### 16. vue的生命周期钩子函数有哪些？各在什么时机执行？mounted和created有什么区别？销毁的钩子函数一般用来做什么处理？

答案：

1. vue的生命周期钩子函数有哪些？各在什么时机执行？

   答：

   一共有8个：

   - beforeCreate	    ：初始化前     
   - created	               ：初始化后
   - beforeMount	     ：组件挂载前
   - mounted	             :  组件挂载后
   - beforeUpdate	    ：DOM更新前
   - updated	              ：DOM更新后
   - beforeDestroy	   ： 组件销毁前
   - destroyed	           ： 组件销毁后

   如果使用keep-alive实现组件缓存，就还会多出2个

   - activated：      组件激活时调用。

   - deactivated： 组件停用时调用。

2. mounted和created有什么区别？

   - created是初始化后，此时可以操作data中的数据 
   - mounted是挂载后，此时可以操作DOM

3. 销毁的钩子函数一般用来做什么处理？

   - beforeDestroy和destroyed里主要处理扫尾工作，如清除定时器，解绑绑定的事件等。

### 27. VUE双向绑定的原理是怎样的？

> 不理解可看视频：
>
> https://www.bilibili.com/video/BV1Dr4y1c7xS?from=search&seid=4704624688515513701&spm_id_from=333.337.0.0

vue2.0中双向绑定主要基于以下两点实现

- 发布者-订阅者模式

- ES5提供的`Object.defineProperty()`劫持数据


要实现Vue中的双向数据绑定，大致可以划分三个模块：Watcher，Observer 和 Compiler 如图：

- Observer数据监听器， 负责对数据对象的所有属性进行劫持，监听到数据发生变化后通知订阅者。
- Compiler指令解析器， 解析模板指令，初始化视图。并订阅数据变化，绑定更新函数。
- Watcher订阅者， 关联Observer和Compiler；订阅并收到属性变动的通知，调用update()，是会触发Compiler中绑定的回调，更新视图。

总的来说：MVVM作为数据绑定的入口，整合Observer、Compiler和Watcher三者，通过Observer来监听自己的数据变化，通过Compile来解析编译模板指令，利用Watcher搭起Observer和Compile之间的通信桥梁，最终达到数据变化 -> 视图自动更新；视图变化-> 更新数据的效果，这就是双向数绑定的原理。

> 补充：vue3和vue2中双向数据数据绑定实现的主要不同之处，是把ES5中的Object.defineProperty()换成了
>
> ES6中的Proxy

### 28. 什么是mvvm模型？

MVVM 即 **Model-View-ViewModel**，它是Vue中实现双向数据绑定的模式。其中：

1. M 是Model 代表模型，或者说数据。
2. V 是 View    代表视图，或者说用户看到的界面。
3. VM 代表 ViewModel 是model数据层和view视图层的双向联动，数据改变会影响视图，视图改变会影响数据

### 29. v-if 和v-show有什么区别？

- `v-if`  是通过创建和销毁实现显示和隐藏。

- `v-show`  元素总是会被创建，通过css样式display:none/block控制显示和隐藏。

- 如果需要频繁地在显示和隐藏之间切换，则使用 `v-show` ；否则，使用 `v-if` 。

### 30. 组件中的data为什么要定义成一个函数，而不是写成对象的形式？

> 防止变量污染

1. 每一个组件都可以被实例成多个组件实例对象；

   ```vue
   <van-button>1<van-button>   // 利用van-button组件得到第一个 van-button组件的实例对象
   <van-button>2<van-button>   // 利用van-button组件得到第二个 van-button组件的实例对象
   ```

2. 如果data写成对象的形式，同一个组件的多个组件实例对象之间使用的将是同一个data对象中的数据，会相互干扰，相互影响。

3. 而把data写成函数的形式则能避免这个问题，每次利用组件实例化组件的实例对象的时候，都会调用data函数得到一个全新的对象，这样多个组件实例对象之间使用数据都是全新的对象，实现了组件实例对象之间的独立和互不干扰。

### 31. 组件之间的传值方式有哪些？

- 父传子，子组件通过`props`接收
- 子传父，子组件使用`$emit`对父组件进行传值
- 通过`eventBus`进行跨组件值传递
- 通过`vuex`进行全局状态管理
- 父组件通过`$ref`获取子组件实例对象，进而传值
- 路由传值
- localStorage、sessionStorage、cookie
- 父子之间通过`$parent`和`$chidren`获取实例进而通信
- `provide`和`inject`，官方不建议使用

### 32. computed、watch和methods有何区别？

- 使用场景上：
  - computed是计算属性，如果某个属性的值是通过其他变量计算出来的，可以使用计算属性
  - watch 是侦听器，用于监听变量或属性的变化，然后去做特定的事情
  - methods 是方法，往往用来完成特定的任务
- 特点上：
  - computed：
    - 具有缓存，依赖值不变不会重新执行代码计算，会复用缓存中的计算结果。
    - **`computed`中不能进行异步操作**
    - 使用的时候当成变量使用即可，不要写成函数调用的形式
  - watch ：
    - `watch `中可以进行异步操作
  - methods：
    - `methods `中可以进行异步操作
    - 使用的时候当成函数使用，需要写成函数调用的形式



### 33 vuex是什么？有哪五个重要的属性？怎么使用？哪种功能场景使用它？

> 是什么：vue框架中全局状态管理工具:
>
> 有哪五个重要的属性节点，分别是 State、 Getter、Mutation 、Action、 Module
>
> 使用：新建一个目录store文件夹，在其中完成Store的实例化操作后，再main.js中导入，并放到new Vue的身上。
>
> 场景：单页应用中，保存不同组件之间共享的状态。如登录状态、加入购物车等。

```js
vuex的State特性
A、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data
B、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新
C、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中

vuex的Getter特性
A、getters 可以对State进行计算操作，它就是Store的计算属性
B、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用
C、 如果一个状态只在一个组件内使用，是可以不用getters

vuex的Mutation特性
改变store中state状态的唯一方法就是提交mutation，就很类似事件。
每个mutation都有一个字符串类型的事件类型和一个回调函数，我们需要改变state的值就要在回调函数中改变。
我们要执行这个回调函数，那么我们需要执行一个相应的调用方法：store.commit。

Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态；
Action 可以包含任意异步操作，Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，
因此你可以调用 context.commit 提交一个 mutation，
或者通过 context.state 和 context.getters 来获取 state 和 getters。
Action 通过 store.dispatch 方法触发：eg。
store.dispatch('increment')

vuex的module特性
Module其实只是解决了当state中很复杂臃肿的时候，module可以将store分割成模块，
每个模块中拥有自己的state、mutation、action和getter
```

### 34 vue中 keep-alive 组件有什么作用？

答：

- keep-alive 是 Vue 内置的一个组件，可以使被包含的组件被缓存起来，避免重新渲染。

```vue
<keep-alive include="A,B">
  <component>
    <!-- 该组件将被缓存！ -->
  </component>
</keep-alive>

<keep-alive exclude="A,B">
  <component>
    <!-- 该组件将被缓存！ -->
  </component>
</keep-alive>


// 如果只想 router-view 里面某个组件被缓存
var routes = [
  {
    path: '/',
    name: 'home',
    component: Home,
    meta: {
      keepAlive: true // 需要被缓存
    }
  }, {
    path: '/:id',
    name: 'edit',
    component: Edit,
    meta: {
      keepAlive: false // 不需要被缓存
    }
  }
]

<keep-alive>
    <router-view v-if="$route.meta.keepAlive">
        <!-- 这里是会被缓存的视图组件，比如 Home！ -->
    </router-view>
</keep-alive>
 
<router-view v-if="!$route.meta.keepAlive">
    <!-- 这里是不被缓存的视图组件，比如 Edit！ -->
</router-view>
```



### 35 vue组件的scoped属性的作用

> 在style标签上添加scoped属性，以表示它的样式作用于当下的模块，很好的实现了样式私有化的目的；
>
> 但是会导致：样式不易修改，很多时候，我们是需要对公共组件的样式做微调的；

**解决办法：**

> ①：使用混合型的css样式：（混合使用全局跟本地的样式）
>
> ```css
> <style> /* 全局样式 */ </style>
> <style scoped> /* 本地样式 */ </style>
> ```
>
> ②：深度作用选择器（>>>）如果你希望 scoped 样式中的一个选择器能够作用得更深，影响子组件，你可以使用 >>> 操作符：
>
> 注意：/deep/ 和 >>> 是一个意思，可以理解是其别名
>
> ```css
> <style scoped> 
> .a >>> .b { /* ... */ } 
> </style>
> ```

```vue
1. ::v-deep  在scss中使用
 
<style scoped lang="scss">
 
  ::v-deep img{
    width: 100px;
    height: 100px;
  }
 
</style>
 
 2. >>> 在less中使用
 
<style scoped lang="less">
 
  >>> img{
    width: 100px;
    height: 100px;
  }
 
</style>
 
 3. /deep/ 在less中使用
 
<style scoped lang="less">
 
  /deep/  img{
    width: 100px;
    height: 100px;
  }
 
</style>
```

### 36. vue-router如何响应 路由参数 的变化？

你可以简单地 watch (监测变化) $route 对象：

```js
{
  ...,
  watch: {
    '$route' (to, from) {
      // 对路由变化作出响应...
    }
  }
}
```

### 37. vue中子组件调用父组件的方法

> 第一种方法是直接在子组件中通过this.$parent.event来调用父组件的方法
> 第二种方法是在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了。
> 第三种方法是把父组件的方法，以属性props的方式传给子组件，然后子组件调用（参考下方代码）
>
> 三种 都可以实现子组件调用父组件的方法，

```vue
<child :fatherMethod="fangfa"/>

methods: {
	fangfa(){
		...父组件中的某个方法
	}
}
```

```vue
<template>
  <div>
    <button @click="childMethod()">点击</button>
  </div>
</template>
<script>
  export default {
    props: {
      fatherMethod: {
        type: Function,
        default: null
      }
    },
    methods: {
      childMethod() {
        if (this.fatherMethod) {
          this.fatherMethod();
        }
      }
    }
  };
</script>
```

### 38 虚拟DOM和DIFF算法

1. vue中是如何提高操作DOM的性能的？

   - 运用虚拟DOM + DIFF算法。
   - 运用虚拟DOM，主要目的是尽量减少对真实DOM的（查询）操作。
   - 运用DIFF算法，主要目的是对比新旧虚拟DOM的差异，找出差异的部分，然后去操作DOM更新有差异的部分，能够尽量减少对真实DOM的操作，只改变应该改变的那部分，从而提高渲染性能。

2. 什么是虚拟DOM，　

   1. 本质是保存节点信息, 属性和内容的一个JS对象

3. 为什么要使用虚拟DOM

   1. **减少了DOM的操作，优化了性能**

      > 减少了对DOM的操作。页面中的数据和状态变化，都通过Vnode对比，只需要在比对完之后更新DOM，不需要频繁操作，提高了页面性能。虚拟DOM的频繁修改操作不会引发回流和重绘，它会一次性对比差异并修改真实DOM，最后才依次进行回流重绘，减少了真实DOM中多次回流重绘引起的性能损耗。

   2. 跨平台性

      > 虚拟DOM本质是JS对象，所以不管Node还是浏览器环境，都可以操作；它抽象了原本的渲染过程，实现了跨平台的能力，它不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是小程序，也可以是各种GUI。

4. 什么是diff算法

   1. diff算法是将新虚拟 DOM 和老虚拟 DOM 进行比较，算出最小差异的算法

5. 为什么需要diff算法

   1. 要尽量减少DOM操作，就得找出新旧虚拟DOM中得最小差异然后去更新，如何找出其中得最小差异，就得通过diff算法

6. diff算法的工作流程是

   1. 逐层从上往下比较
2. 根元素变化，删除整个重建
   3. 根元素不变，属性改变更新属性
   4. 子元素比较的时候，如果无key则就地更新
   5. 子元素比较的时候，如果有key则按照key比较更新

### 39 路由守卫/路由钩子函数

1. 说说路由钩子函数有哪几个？执行时机是？

   1. **前置路由守卫beforeEach  执行时机：跳转路由前**
   2. **后置路由守卫 afterEach    执行时机： 路由跳转后**

2. 路由守卫应用场景？

   1. 可以在路由守卫中统一进行用户是否登录认证的判断，如没有token就让用户不能访问需要进行用户认证才能访问的页面，跳回登录页。

3. 路由钩子函数分为哪3类

   1. 全局钩子

      > 针对所有路由生效

      ```js
      router.beforeEach(async(to, from, next) => {
          // 所有路由切换前先执行的代码
      })
      ```

   2. 路由独享钩子

      > 针对特定路由生效

      ```js
      routes: [
        {
          path: '/xxx',
          component: xxx,
          beforeEnter: (to, from, next) => {
            // 跳转路由到/xxx前先执行的代码
          }
        }
      ]
      ```

   3. 组件内路由钩子

      - beforeRouteEnter(to, from, next)：跳转路由渲染组件时触发

        ```vue
        <script>
        export default {
          name: 'feedbackMgt',
          beforeRouteEnter(to, from, next) {
              // 跳转路由渲染本组件时触发执行的代码
          }
        }
        </script>    
        ```

      - beforeRouteUpdate(to, from, next)：跳转路由且组件被复用时触发

      - beforeRouteLeave(to, from, next)：跳转路由且离开组件时触发

### 40. vue中有时会出现页面闪现的问题，如何解决？

**使用v-clock指令即可解决**

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    <style>
        /* 1. 给[v-clock]属性选择器添加隐藏样式 */
        [v-clock]{
            display: none;
        }
    </style>
</head>

<body>
    <!-- 2. 给需要控制不闪现的标签或组件添加v-clock指令(vue会再完成渲染后移除v-clock属性) -->
    <div id="app" v-clock>
        {{ message }}
    </div>
    <script>

        setTimeout(()=>{
            var app = new Vue({
            el: '#app',
            data: {
                message: 'Hello Vue!'
            }
        })
        }, 2000)

     
    </script>
</body>

</html>
```

## 四、项目 + 其他

### 40 git命令

1. 问题 1：创建本地仓库有两种方式，直接创建和克隆，命令分别是？

   ```shell
   git init
   
   git clone 远程仓库地址
   ```

2. 问题 2：git日常工作的全流程是？

   1. 拉取最新代码

      ```shell
      git pull
      ```

   2. 修改代码文件

   3. 添加暂存

      ```shell
      git add .
      ```

   4. 提交仓库

      ```shell
      git commit -m "注释内容"
      ```

   5. 推送到远程仓库

      ```shell
      git push
      ```

3. 问题 3：分支相关的命令有哪些？

   - 查看分支

     ```shell
     git branch
     ```

   - 创建并切换到新分支

     ```shell
     git checkout -b 新分支名
     ```

   - 切换分支

     ```shell
     git checkout 分支名
     ```

   - 合并分支

     ```shell
     git merge 被合并的分支
     ```

4. 问题 4：查看状态的命令是？

   ```shell
   git status
   ```

5. 问题 5：查看历史记录和跳转指定版本的命令是？

   - 查看过去历史

     ```shell
     git log
     ```

   - 查看所有历史

     ```shell
     git reflog
     ```

   - 跳转指定版本

     ```shell
     git reset --hard 版本id
     ```

### 41. webpack是什么？具体有哪些作用？loader和plugin分别是干嘛的？webpack的工作流程是怎样的？

1. webpack 是一个模块打包工具，是node.js中的一个第三方包

2. 具体来说有以下4点作用:
   1. 语法降级：如ES6/7/8 => ES5
   2. 翻译：如less/sacc => css
   3. 压缩代码：如除去空格换行
   4. 合并：多个文件合成一个文件

3. loader和plugin分别是干嘛的？

   1. 由于webpack默认只支持js文件
   2. loader是加载器：把原本不支持的模块转换为webpack支持的模块
   3. plugin是插件： 用于扩张webpack 的功能，在webpack构建生命周期的过程中，在合适的时机做了合适的事情。

4. webpack的工作流程是怎样的？

### 42. 谈谈你平时都用了哪些方法进行性能优化？

1. 减少http请求次数

2. 打包压缩上线代码

3. 图片懒加载

   原理

   1. 页面加载完后，img标签没有src属性，真实的图片路径存在另外的属性如data-src属性中, 所以默认并不会发送获取图片的网络请求。

      ```html
      <img data-src="aaa.jpg"/>
      ```

   2. 当js探测到img标签出现在可视区域的时候，拿到data-src属性的属性值，作为src属性的属性值，这时候才会发送获取图片的网络请求。

      ```html
      <img data-src="aaa.jpg" src="aaa.jpg"/>
      ```

4. 使用雪碧图

5. vue路由懒加载

6. CDN加载包。

   各地搞很多的服务器，不同地方的人访问的时候，就找到最近的服务器来下载资源，如下方bootstrap官网上访问的外链资源地址中有cdn，就应该是部署在专门的cdn服务器上的，这种资源访问起来就会比较快。


### 43 安全方面的CSRF攻击 和 XSS攻击（了解）

1. 什么是CSRF？

   **跨站请求伪造  Cross-site request forgery**

   用户同时在浏览器上打开了AB两个网站

   A银行网站已登录，登录信息记录在cookie中

   B网站  通过表单给A银行网站发起转账请求。由于A网站事先已登录  钱被转走。

2. 什么是XSS

   **跨站脚本攻击  Cross-site scripting**

   A银行网站登录，攻击者在A网站内嵌套一段script脚本，用户访问A网站嵌套了脚本的网页的的时候，执行script脚本代码，钱被转走。

3. CSRF和XSS有什么区别

   XSS利用的是用户对指定网页的信任，CSRF利用的是网站对用户网页浏览器的信任。

4. 如何避免CSRF攻击

   **方法一、Token 验证：**（用的最多）

   1. 服务器发送给客户端一个`token`；
   2. 客户端提交的表单中带着这个`token`。
   3. 如果这个 `token` 不合法，那么服务器拒绝这个请求。

   **方法二：隐藏令牌：**

   把 `token` 隐藏在 `http` 的 `head`头中。

   方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。

   **方法三、Referer 验证：**

   `Referer` 指的是页面请求来源。意思是，**只接受本站的请求，服务器才做响应**；如果不是，就拦截

5. 如何避免XSS攻击

   **1. 编码**：

   对用户输入的数据进行`HTML Entity`编码。

   如上图所示，把字符转换成 转义字符。

   Encode`的作用是将`$var`等一些字符进行转化，使得浏览器在最终输出结果上是一样的。

   比如说这段代码：

   ```javascript
   <script>alert(1)</script>
   ```

   > 若不进行任何处理，则浏览器会执行alert的js操作，实现XSS注入。进行编码处理之后，L在浏览器中的显示结果就是`<script>alert(1)</script>`，实现了将``$var`作为纯文本进行输出，且不引起J`avaScript`的执行。

   **2、过滤：**

   - 移除用户输入的和事件相关的属性。如`onerror`可以自动触发攻击，还有`onclick`等。（总而言是，过滤掉一些不安全的内容）
   - 移除用户输入的`Style`节点、`Script`节点、`Iframe`节点。（尤其是`Script`节点，它可是支持跨域的呀，一定要移除）。

   **3、校正**

   - 避免直接对`HTML Entity`进行解码。
   - 使用`DOM Parse`转换，校正不配对的`DOM`标签。

   备注：我们应该去了解一下`DOM Parse`这个概念，它的作用是把文本解析成`DOM`结构。

   比较常用的做法是，通过第一步的编码转成文本，然后第三步转成`DOM`对象，然后经过第二步的过滤。

### 44 某某项目中登录/注册/文章列表/权限管理...功能是如何实现的？

- 尽量简洁的回答该问题
- 不要过多牵扯代码
- 尽量说出1、2、3、4点

### 45 某某项目中亮点，难点，最有成就感的是？

- 有意识的准备简历项目的同时准备回答该问题
- 尽量说出2点以上，而不是没有

### 46 **自我介绍（必问 第一印象 重要 重要 非常重要）**

- 先准备一个逐字稿，背诵到不像背诵为止

- 时间控制在 2 - 5分钟

- 扬长避短

- 可以多说说（工作中做过的/学过的）项目的经历

  ```
  1. 说出自己的名字
  2. 说出自己的工作和项目经验
  ```



## 五、43期面试遇到的新的面试题

### 48. 这个人资/商城/...管理系统中权限是怎样做的？   

1. 我们采用了基于角色的权限设计思想，具体来说就是给用户分配角色，给角色分配权限，用户就间接拥有角色上的所有权限。

2. 总的来说分为两大模块：权限基本信息维护和权限控制，具体来说

   1. 权限基本信息维护包含：用户管理、权限管理、角色管理、为用户分配角色， 为角色分配权限
   2. 权限控制包含，路由权限的控制 和 按钮权限的控制

3. 具体实现上：

   1. 权限基本信息维护没有什么好说的，就是一些增删改查的操作

   2. 我重点说说权限控制吧

      1. 先说路由权限的控制，在实现路由权限控制的时候
         1.  我们首先在路由守卫中调用接口获取用户信息，用户信息身上会有权限标识数组
         2.  然后我们会利用所有动态路由数组，和刚刚拿到的权限标识数组，得到当前用户能访问的动态路由数组
         3.  我们会把 用户能访问的动态路由数组 丢到vuex里面，基于vuex中的数据，渲染出后台主页左侧的导航菜单
         4.  最后我们还会通过 router.addRoutes 把 用户能访问的动态路由数组 添加到动态路由中，这样用户通过导航菜单访问的时候就不是空白页
      2. 再说按钮权限的控制，在实现按钮权限控制的时候：
         1. 我们首先会在混入mixins中定义一个方法，该方法接收特定权限标识，比如添加用户就可以约定是 add_users, 在函数内我们会去权限标识数组中查找有无该权限标识，如果有返回true, 如果没有返回false
         2. 之后我们通过Vue.mixin()对该混入做全局混入，这样每个组件内都可以调用该方法了
         3. 最后我们在模板template中通过调用该方法判断有无权限，如果没有权限就隐藏按钮
      3. 当然还要提一嘴的是，接口权限控制是由后台控制的，如果我没有新增用户的权限，去调用新增用户的接口的时候，接口就应该返回一个403没有权限的状态码

      面试官你好，这就是我们这个后台管理项目中权限的做法

### 49. 项目中解决了从详情返回列表页的时候停留在原点的问题，说说你是怎样解决的？ 

1. 使用keep-alive缓存列表页组件。
2. 监听列表页组件中滚动的盒子的滚动条滚动事件scroll，把滚动条滚动的距离存储起来（比如可以存储到某个DOM元素的属性中）。
3. 在列表页组件的重新激活的钩子函数activated中，拿到之前存储的滚动的距离，设置为滚动的盒子的scrollTop属性属性值，这样问题就解决了。

### 49. 你在使用系统的时候，如果管理员对你的权限做了更改，怎么办？

1. 不做任何处理（后端会控制接口的权限）

2. 使用定时器 隔20秒 调接口获取最新的权限，然后更新存储在vuex或其地方和权限相关的数据

3. websockt  (全双工的通信)

### 50. script 标签中 defer 和 async 的区别？

> 面试官可能会问你：遇到一个script标签

- `script` ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。
- `async script` ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。
- `defer script`：完全不会阻碍 HTML 的解析，解析完成之后再按照顺序执行脚本。

### 51. 从浏览器地址栏输入 url 按回车后发生了什么

1. 浏览器首先会从URL地址中解析出协议、主机、端口、路径等信息并构造一个 HTTP 请求。

2. DNS域名解析，把域名翻译成IP地址。   （[字节面试被虐后，是时候搞懂 DNS 了](https://juejin.cn/post/6990344840181940261)）

3. 浏览器和服务器建立TCP 连接。

   > 总是要问：为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点**可靠传输**决定的。客户端和服务端要进行可靠传输，那么就需要**确认双方的接收和发送能力**。第一次握手可以确认客服端的**发送能力**，第二次握手，确认了服务端的**发送能力和接收能力**，所以第三次握手才可以确认客户端的**接收能力**。不然容易出现丢包的现象。

4. 浏览器基于TCP协议发送HTTP请求报文。

5. 服务器处理请求并返回HTTP 报文。

6. 浏览器和服务器断开TCP 连接。

7. 浏览器渲染页面。

### 52 浏览器的渲染机制是怎样的？

参考：https://juejin.cn/post/6844903779700047885

浏览器渲染过程如下分为5步：

> 注意：回流和重排是一个意思   回流===重排

1. 解析HTML，生成DOM树，解析CSS，生成CSSOM树
2. 将DOM树和CSSOM树结合，生成渲染树(Render Tree)
3. Layout(回流): 根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）
4. Painting(重绘): 根据渲染树以及回流得到的几何信息，得到节点的绝对像素
5. Display: 将像素发送给GPU，展示在页面上。

### 53 什么是重排？什么是重绘？什么情况下会导致重排？如何减少重排重绘？

参考：

https://blog.csdn.net/qq_38164763/article/details/105406580

https://juejin.cn/post/6844903779700047885

> 面试官问的时候可能会这样问：
>
> 问：修改盒子的宽度和修改盒子的背景颜色哪个更消耗性能
>
> 答：修改盒子的宽度？
>
> 问：为什么？
>
> 答：因为修改盒子的宽度属于修改几何属性会导致重排，而修改背景演示属于非几何属性的修改，只会导致重绘

什么是重排？什么是重绘？

- 重排Layout：当DOM的变化引发了元素几何属性的变化，比如改变元素的宽高，元素的位置，导致浏览器不得不重新计算元素的几何属性，并重新构建渲染树，这个过程称为“重排”。
- 重绘Painting：完成重排后，要将重新构建的渲染树渲染到屏幕上，这个过程就是“重绘”。
- 重排一定会导致重绘，重绘不一定需要重排。

哪些操作会导致重绘和重排？

- 添加或删除可见的DOM元素
- 元素的位置发生变化
- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
- 页面一开始渲染的时候（这肯定避免不了）
- 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）
- 以及获取如下属性的时候
  1. offsetTop、offsetLeft、offsetWidth、offsetHeight
  2. scrollTop、scrollLeft、scrollWidth、scrollHeight
  3. clientTop、clientLeft、clientWidth、clientHeight
  4. getComputedStyle()
  5. getBoundingClientRect

如何减少重排和重绘？

- **最小化重绘和重排**，比如样式集中改变，使用添加新样式类名 `.class` 或 `cssText` 。
- **批量操作 DOM**
  - 隐藏元素，应用修改，重新显示
  - 使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。
  - 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。
  - 但
- **对于复杂动画效果,使用绝对定位让其脱离文档流**，这在制作复杂的动画时对性能的影响比较明显。

### 54. 说说你对浏览器缓存的认识？

> 参考+必读：https://juejin.cn/post/6844903763665240072

1. 什么是缓存？ 

   - 简单点说就是：第一次访问服务器之后，浏览器把服务器返回的结果存储起来


      - 下次再访问的时候，直接从缓存中取，就不需要再请求服务器了。


2. 为什么需要缓存？ 

   - 减少网络请求，降低了服务器的压力

   - 优化访问资源的速度，提升了用户体验。


3. 哪些资源可以被缓存？ 

   - 一段事件内不会变化的服务器资源，比如静态资源js css img。

4. 浏览器缓存的两种类型？

   - 强缓存

   - 协商缓存

5. 缓存的优先级是怎样的？

   - 先走强缓存，强缓存无效，再走协商缓存

6. **强缓存**

   主要是看 response headers 中的 Cache-Control 的值，如果max-age=60，就是说在60秒内，都直接使用缓存，超过了就继续请求服务器

   > Cache-Control所有取值：  https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control

   Cache-Control的取值包含：

   - public: 表明响应可以被任何对象（包括：浏览器，代理服务器，等等）缓存。
- private: 表明响应只能被用户本地浏览器缓存。
   - no-cache：在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证(协商缓存验证)。
   - no-store：缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。
   - max-age: 设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与`Expires`相反，时间是相对于请求的时间。
   - must-revalidate: 一旦资源过期（比如已经超过`max-age`），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。
   
   Cache-Control示例：

   - 禁止缓存：发送如下响应头可以关闭缓存。

     ```
  Cache-Control: no-store
     ```
   
   - 缓存静态资源：对于应用程序中不会改变的文件，你通常可以在发送响应头前添加积极缓存。这包括例如由应用程序提供的静态文件，例如图像，CSS文件和JavaScript文件。

     ```
  Cache-Control:public, max-age=31536000
     ```
   
   - 需要重新验证

     指定 `no-cache` 或 `max-age=0, must-revalidate` 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起 HTTP 请求，但当缓存内容仍有效时可以跳过 HTTP 响应体的下载。

     ```
  Cache-Control: no-cache
     ```
   
     ```
  xxxxxxxxxx Cache-Control: max-age=0, must-revalidate	
     ```
   
7. 协商缓存

   强缓存没有命中就会走协商缓存

   协商缓存触发条件如下：

   1. Cache-Control 的值**不能是no-store**（既不强缓存，也不协商缓存）
   2. Cache-Control 的值为 **no-cache （不强缓存）或者  过去的秒数超过max-age**（强缓存，但总有过期的时候）

   协商缓存也有响应头和请求头决定

   1. 第一次请求的时候，服务器会返回资源，并在响应头中携带一个 `etag`和`last-modified`,

      `etag`是资源标识（如 `51586dff-686`），`last-modified`是资源在服务器上的最近一次修改的时间（如 `Sun, 31 Mar 2013 17:10:23 GMT`）

   2. 第二次请求的时候该资源的时候，浏览器会自动在请求头中，携带`etag`和`last-modified`,

      只是名字变了`etag -> if-none-match` （如 `51586dff-686`）和`last-modified -> if-modified-since`（如 `Sun, 31 Mar 2013 17:10:23 GMT`）

      服务器接收到请求后，会根据这两个请求头判断资源有无更新

      如果资源没有更新过，这时候服务器会返回 304的状态码，浏览器知道服务器上资源没有更新过，因此就直接去缓存中取出资源数据使用。

      如果有更新，这时候会返回`200状态码`、`新的资源`， `etag`和`last-modified`，浏览器会重新缓存数据。

   概况来说

   1. 请求资源时，把用户本地该资源的 ETag 同时带到服务端，服务端和最新资源做对比。
2. 如果资源没更改，返回304，浏览器读取本地缓存。
   3. 如果资源有更改，返回200，返回最新的资源。

8. 其他：

   1. 命中显示

      1. 从服务器获取新的资源

      2. 命中强缓存，且资源没过期，直接读取本地缓存

      3. 命中协商缓存，且资源未更改，读取本地缓存

         注意：协商缓存无论如果，都要向服务端发请求的，只不过，资源未更改时，返回的只是header信息，所以size很小；而资源有更改时，还要返回body数据，所以size会大。

   2. 为什么有了last-modified 还需要 etag

      你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现（也就是说，ETag是新增的，为了解决之前只有If-Modified的缺点）主要是为了解决几个Last-Modified比较难解决的问题：

      - 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
   - 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；
      - 某些服务器不能精确的得到文件的最后修改时间

   3. 强缓存和协商缓存的区别

   4. 用户行为对缓存的影响
   
   5. 项目中如何应用缓存？

      比如 vue 项目，脚手架已经将更改的文件做 hash 处理了，因此一般的 js、css 文件不需要我们再去操作。

      而对于 index.html，我们需要在 nginx 上做 no-store 处理，即完全不缓存 index.html，每次都请求最新的html。。。因为 html 中会外链 css、js，如果我 html 还是走的缓存，那链接的还是老的 css 啊，想想？？？

9. **缓存的流程图**

### 54. 深入理解缓存

### https://juejin.cn/book/6844733750048210957/section/6844733750106931214

### 55. 如何判断数据类型？

1. **typeof**：能判断所有**值类型，函数**。不可对 **null、对象、数组**进行精确判断，因为都返回 `object` 。

   ```js
   console.log(typeof undefined); // undefined
   console.log(typeof 2); // number
   console.log(typeof true); // boolean
   console.log(typeof "str"); // string
   console.log(typeof Symbol("foo")); // symbol
   console.log(typeof 2172141653n); // bigint
   console.log(typeof function () {}); // function
   // 不能判别
   console.log(typeof []); // object
   console.log(typeof {}); // object
   console.log(typeof null); // object
   ```

2. **instanceof**：能判断**对象**类型，不能判断基本数据类型，**其内部运行机制是判断在其原型链中能否找到该类型的原型**。比如考虑以下代码：

   其实现就是顺着**原型链**去找，如果能找到对应的 `Xxxxx.prototype` 即为 `true` 。比如这里的 `vortesnail` 作为实例，顺着原型链能找到 `Student.prototype` 及 `People.prototype` ，所以都为 `true` 。

   ```js
   class People {}
   class Student extends People {}
   
   const vortesnail = new Student();
   
   console.log(vortesnail instanceof People); // true
   console.log(vortesnail instanceof Student); // true
   ```

3. **Object.prototype.toString.call()**：所有原始数据类型都是能判断的，还有 **Error 对象，Date 对象**等。

   ```js
   Object.prototype.toString.call(2); // "[object Number]"
   Object.prototype.toString.call(""); // "[object String]"
   Object.prototype.toString.call(true); // "[object Boolean]"
   Object.prototype.toString.call(undefined); // "[object Undefined]"
   Object.prototype.toString.call(null); // "[object Null]"
   Object.prototype.toString.call(Math); // "[object Math]"
   Object.prototype.toString.call({}); // "[object Object]"
   Object.prototype.toString.call([]); // "[object Array]"
   Object.prototype.toString.call(function () {}); // "[object Function]"
   ```

### 56. 在面试中有一个经常被问的问题就是：如何判断变量是否为数组？

```javascript
var arr = [1, 2, 3]
// 1. Array.isArray
Array.isArray(arr); // true
// 2. instanceof
arr.__proto__ === Array.prototype; // true
arr instanceof Array; // true
// 3. Object.prototype.toString.call
Object.prototype.toString.call(arr); // "[object Array]"
```

### 55. HTTP和HTTPS的区别

- HTTPS =  SSL（加密协议） + HTTP

- 区别：

  - HTTP是明文传输的，不安全。   
  - HTTPS是会加密传输，是安全的。

### 56. 为什么需要微信登录？说说小程序微信登录的流程？

1. 调用wx.login得到一个code
2. 利用code调用后台接口，得到token
3. 把token存储起来方便下一次使用

### 57. 说说小程序微信支付的流程是怎样的？  

1. 客户端调用创建订单的接口，拿到订单id
2. 利用订单id，调用预支付的接口，得到支付的相关参数
3. 利用支付相关参数调用wx.requestPayment在微信客服端发起微信支付
4. 利用订单id，调用检查订单是否支付成功的接口，实现了闭环

### 58. src和href之间有什么区别？

- src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。

- src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置;在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。

  ```
  <script src ="aa.js" ></script>
  ```

  当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。

- `href`是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素(锚点)或当前文档(链接)之间的链接，如果我们在文档中添加

  ```
  <link href="common.css" re1="stylesheet"/>
  ```

  那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link 方式来加载css，而不是使用@import方式

  

### 59. 发请求想中断怎么办？

- 原生的xhr中可以通过 .abort中断请求的发送

  ```js
  const xhr = new XMLHttpRequest()
  xhr.open('get', 'http://127.0.0.1:3000/get', true)
  xhr.send()
  // 通过调用xhr的abort方法取消请求的发送
  xhr.abort()
  ```

- `axios`中可以通过`cancelToken`取消请求的发送，但本质上还是通过调用xhr的abort实现

  ```js
  import axios from 'axios'
  
  let cancel
  axios({
      method: 'GET',
      url: 'http://127.0.0.1:3000/get',
      cancelToken: new axios.CancelToken(function executor (c) {
          // executor 函数接收一个 cancel 函数作为参数
          cancel = c
      })
  })
  // 取消发送网络请求
  cancel('取消请求发送')
  ```

### 60. 数字精度怎么处理?     

>https://juejin.cn/post/7090940938184294407
>
>https://blog.csdn.net/moguzhale/article/details/105931262

- 什么是数字精度问题？

  我们在计算`0.1 + 0.2`的结果并不是`0.3`,而是0.30000000000000004这种现象就称为数字精度问题

- 为什么会出现数字精度问题？

  因为`js`采用IEEE 754的双精度标准进行数字存储,这是一种64位双精度浮点数储存方法，会出现精度的丢失

- 解决这个问题的思路：

  把小数转换成整数，再计算就不会出问题

- 具体项目中怎么做的？

  - 写一个自己的用来计算加减乘除的方法, 如下面就写了一个加法

    ```js
    function add(num1, num2){
      let r1, r2, m;
      r1 = num1.toString().split('.')[1].length
      r2 = num2.toString().split('.')[1].length
      m = Math.pow(10, Math.max(r1, r2))
      return (num1 * m + num2 * m) / m
    }
    
    // 以后计算 0.1 + 0.2 的时候就可以写成
    add(0.1, 0.2)
    ```

  - 使用第三方包 decimal.js

    https://mikemcl.github.io/decimal.js/#

    ```js
  0.1 + 0.2                                // 0.30000000000000004
    x = new Decimal(0.1)
    y = x.plus(0.2)                          // '0.3'
    new Decimal(0.7).plus(x).plus(y)         // '1.1'
    ```

### 61. 说说css的权重 

- 选择器权重表如下：

  | 选择器               | 选择器权重 |
  | -------------------- | ---------- |
  | 继承 或 *            | 0, 0, 0, 0 |
  | 元素选择器           | 0, 0, 0, 1 |
  | 类选择器，伪类选择器 | 0, 0, 1, 0 |
  | ID选择器             | 0, 1, 0, 0 |
  | 行内样式 style       | 1, 0, 0, 0 |
  | !important           | 无穷大     |

- 使用选择器时的注意事项

  1. 权重是有4组数字组成,但是不会有进位。
  2. 可以理解为类选择器永远大于元素选择器, id选择器永远大于类选择器,以此类推.. 
  3. 等级判断从左向右，如果某一位数值相同，则判断下一位数值。 
  4. 可以简单记忆法: 通配符和继承权重为0, 标签选择器为1,类(伪类)选择器为 10, id选择器 100, 行内样式表为 1000, !important 无穷大. 
  5. 继承的权重是0， 如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是 0。

### 62. 做过哪些性能优化，是怎样处理的？   

>https://juejin.cn/post/6892994632968306702
>
>https://juejin.cn/post/6981673766178783262

- 减少`http`请求次数
- 使用HTTP2.0
- 使用服务端渲染SSR
- 静态资源使用cdn
- 使用缓存
- 使用字体图标和精灵图
- 图片懒加载
- 路由懒加载
- 减少重排重绘
- 事件委托
- css放头部js放尾部
- 不要优化过渡，不能为了优化而优化

### 63. 做过哪些兼容性处理？

https://juejin.cn/post/6972937716660961317

### 64. hash和history路由有哪些区别

https://juejin.cn/post/6993840419041706014

https://juejin.cn/post/7096034733649297421

### 65. 列表项有上万项，怎么办？

- 会导致什么问题？页面上DOM元素太多
- 使用**长列表**技术：原理：只渲染可视区域内的DOM
- 比如在vue中可以使用 `vue-virtual-scroller` 实现长列表

### 66. 如何判断this的指向？

- 普通函数内:   this指向调用者，谁调用指向谁
- 箭头函数内：箭头函数定义的位置this指向什么，箭头函数的内部的this就指向什么

### 67. mixins有没有了解，在你做的项目中如何应用的？

> https://juejin.cn/post/6858174634019192845 

- mixins是混入，是一种分发 Vue 组件中可复用功能的非常灵活的方式
- mixins是一个js对象，它可以包含我们组件中script项中的任意功能选项，如data、components、methods 、created、computed等。我们只要将共用的功能以对象的方式传入mixins选项中，当组件使用 mixins对象时所有mixins对象的选项都将被混入该组件本身的选项中来，这样就可以提高代码的重用性，使你的代码保持干净和易于维护。

### 68. null和undfined有什么区别？

> https://juejin.cn/post/7051144396615450655

### 69. $set有什么用？

- 有时候我们修改组件内部data中的数据，但是发现vue探测不到数据的变化，视图上的内容没有跟着改变，这时候我们就可以使用$set来解决这个问题

  > 举例：见注释

  ```js
  export default {
    name: 'App',
    data () {
      return {
        arr: [1, 2, 3]
      }
    },
    created () {
      // 1.1 下面这行代码vue探测不到数组数据的变化  
      this.arr[1] = 'test'
      // 1.2 改成$set之后vue就能探测到数据的变化  this.$set(traget, key, value)
      this.$set(this.arr, 1, 'test')
        
      // 1.3 下面这行代码vue探测不到添加了新属性
      this.age = 18
      // 1.4 改成下面这行代码之后vue就能探测到新属性的添加了
      this.$set(this, 'age', 18)  
    }
  }
  ```

### 70. 外边距重叠怎么解决？

https://juejin.cn/post/7026886412179865636

### 73. rem和em的区别

相同点：

- 都是相对单位

不同点：

- rem
  - 1rem = html根元素的font-size的大小
  - 应用场景：做rem适配
- em
  - 1em = 当前标签的font-size的大小
  - em的使用场景：段落首行缩进两个空格

### 74. $attrs 的作用  

https://juejin.cn/post/7008811358380621854

### 75. 为什么vue组件样式不会重叠覆盖呢？scoped的原理

https://juejin.cn/post/7098569051860893709

### 76. less和sass的区别

https://juejin.cn/post/6906845910157525000

### 79. 路由模式history和hash有什么区别？  

https://juejin.cn/post/6867875626611654663

### 80. 为什么有时候修改了data中的数据，视图中没有发生变化

- 因为vue在监听数据变化的时候

  - 如果是对象，是在一开始的时候通过`Object.defineproperty`来劫持对象属性的变化的。
  - 而对于数组而言vue是通过重写数组的方法来监听数组的变化的。

- 所以，如果我们给对象添加新属性，或者通过中括号+索引的方式 `如：this.arr[1] = 'aa'`  来修改数组的时候，vue是探测不到的。

- 这时候我们可以通过$set来解决这个问题。

  ```js
  export default {
    name: 'App',
    data () {
      return {
        arr: [1, 2, 3]
      }
    },
    created () {
      // 1.1 下面这行代码vue探测不到数组数据的变化  
      this.arr[1] = 'test'
      // 1.2 改成$set之后vue就能探测到数据的变化  this.$set(traget, key, value)
      this.$set(this.arr, 1, 'test')
        
      // 1.3 下面这行代码vue探测不到添加了新属性
      this.age = 18
      // 1.4 改成下面这行代码之后vue就能探测到新属性的添加了
      this.$set(this, 'age', 18)  
    }
  }
  ```

  



